// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package proxy

import (
	"sync"
)

// Ensure, that RouteMock does implement Route.
// If this is not the case, regenerate this file with moq.
var _ Route = &RouteMock{}

// RouteMock is a mock implementation of Route.
//
//	func TestSomethingThatUsesRoute(t *testing.T) {
//
//		// make and configure a mocked Route
//		mockedRoute := &RouteMock{
//			NewSelectorFunc: func() Selector {
//				panic("mock out the NewSelector method")
//			},
//		}
//
//		// use mockedRoute in code that requires Route
//		// and then make assertions.
//
//	}
type RouteMock struct {
	// NewSelectorFunc mocks the NewSelector method.
	NewSelectorFunc func() Selector

	// calls tracks calls to the methods.
	calls struct {
		// NewSelector holds details about calls to the NewSelector method.
		NewSelector []struct {
		}
	}
	lockNewSelector sync.RWMutex
}

// NewSelector calls NewSelectorFunc.
func (mock *RouteMock) NewSelector() Selector {
	if mock.NewSelectorFunc == nil {
		panic("RouteMock.NewSelectorFunc: method is nil but Route.NewSelector was just called")
	}
	callInfo := struct {
	}{}
	mock.lockNewSelector.Lock()
	mock.calls.NewSelector = append(mock.calls.NewSelector, callInfo)
	mock.lockNewSelector.Unlock()
	return mock.NewSelectorFunc()
}

// NewSelectorCalls gets all the calls that were made to NewSelector.
// Check the length with:
//
//	len(mockedRoute.NewSelectorCalls())
func (mock *RouteMock) NewSelectorCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNewSelector.RLock()
	calls = mock.calls.NewSelector
	mock.lockNewSelector.RUnlock()
	return calls
}

// Ensure, that SelectorMock does implement Selector.
// If this is not the case, regenerate this file with moq.
var _ Selector = &SelectorMock{}

// SelectorMock is a mock implementation of Selector.
//
//	func TestSomethingThatUsesSelector(t *testing.T) {
//
//		// make and configure a mocked Selector
//		mockedSelector := &SelectorMock{
//			HasNextAvailableServerFunc: func() bool {
//				panic("mock out the HasNextAvailableServer method")
//			},
//			ResetFunc: func()  {
//				panic("mock out the Reset method")
//			},
//			SelectForDeleteFunc: func(key string) []ServerID {
//				panic("mock out the SelectForDelete method")
//			},
//			SelectServerFunc: func(key string) ServerID {
//				panic("mock out the SelectServer method")
//			},
//			SetFailedServerFunc: func(server ServerID)  {
//				panic("mock out the SetFailedServer method")
//			},
//		}
//
//		// use mockedSelector in code that requires Selector
//		// and then make assertions.
//
//	}
type SelectorMock struct {
	// HasNextAvailableServerFunc mocks the HasNextAvailableServer method.
	HasNextAvailableServerFunc func() bool

	// ResetFunc mocks the Reset method.
	ResetFunc func()

	// SelectForDeleteFunc mocks the SelectForDelete method.
	SelectForDeleteFunc func(key string) []ServerID

	// SelectServerFunc mocks the SelectServer method.
	SelectServerFunc func(key string) ServerID

	// SetFailedServerFunc mocks the SetFailedServer method.
	SetFailedServerFunc func(server ServerID)

	// calls tracks calls to the methods.
	calls struct {
		// HasNextAvailableServer holds details about calls to the HasNextAvailableServer method.
		HasNextAvailableServer []struct {
		}
		// Reset holds details about calls to the Reset method.
		Reset []struct {
		}
		// SelectForDelete holds details about calls to the SelectForDelete method.
		SelectForDelete []struct {
			// Key is the key argument value.
			Key string
		}
		// SelectServer holds details about calls to the SelectServer method.
		SelectServer []struct {
			// Key is the key argument value.
			Key string
		}
		// SetFailedServer holds details about calls to the SetFailedServer method.
		SetFailedServer []struct {
			// Server is the server argument value.
			Server ServerID
		}
	}
	lockHasNextAvailableServer sync.RWMutex
	lockReset                  sync.RWMutex
	lockSelectForDelete        sync.RWMutex
	lockSelectServer           sync.RWMutex
	lockSetFailedServer        sync.RWMutex
}

// HasNextAvailableServer calls HasNextAvailableServerFunc.
func (mock *SelectorMock) HasNextAvailableServer() bool {
	if mock.HasNextAvailableServerFunc == nil {
		panic("SelectorMock.HasNextAvailableServerFunc: method is nil but Selector.HasNextAvailableServer was just called")
	}
	callInfo := struct {
	}{}
	mock.lockHasNextAvailableServer.Lock()
	mock.calls.HasNextAvailableServer = append(mock.calls.HasNextAvailableServer, callInfo)
	mock.lockHasNextAvailableServer.Unlock()
	return mock.HasNextAvailableServerFunc()
}

// HasNextAvailableServerCalls gets all the calls that were made to HasNextAvailableServer.
// Check the length with:
//
//	len(mockedSelector.HasNextAvailableServerCalls())
func (mock *SelectorMock) HasNextAvailableServerCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockHasNextAvailableServer.RLock()
	calls = mock.calls.HasNextAvailableServer
	mock.lockHasNextAvailableServer.RUnlock()
	return calls
}

// Reset calls ResetFunc.
func (mock *SelectorMock) Reset() {
	if mock.ResetFunc == nil {
		panic("SelectorMock.ResetFunc: method is nil but Selector.Reset was just called")
	}
	callInfo := struct {
	}{}
	mock.lockReset.Lock()
	mock.calls.Reset = append(mock.calls.Reset, callInfo)
	mock.lockReset.Unlock()
	mock.ResetFunc()
}

// ResetCalls gets all the calls that were made to Reset.
// Check the length with:
//
//	len(mockedSelector.ResetCalls())
func (mock *SelectorMock) ResetCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockReset.RLock()
	calls = mock.calls.Reset
	mock.lockReset.RUnlock()
	return calls
}

// SelectForDelete calls SelectForDeleteFunc.
func (mock *SelectorMock) SelectForDelete(key string) []ServerID {
	if mock.SelectForDeleteFunc == nil {
		panic("SelectorMock.SelectForDeleteFunc: method is nil but Selector.SelectForDelete was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	mock.lockSelectForDelete.Lock()
	mock.calls.SelectForDelete = append(mock.calls.SelectForDelete, callInfo)
	mock.lockSelectForDelete.Unlock()
	return mock.SelectForDeleteFunc(key)
}

// SelectForDeleteCalls gets all the calls that were made to SelectForDelete.
// Check the length with:
//
//	len(mockedSelector.SelectForDeleteCalls())
func (mock *SelectorMock) SelectForDeleteCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	mock.lockSelectForDelete.RLock()
	calls = mock.calls.SelectForDelete
	mock.lockSelectForDelete.RUnlock()
	return calls
}

// SelectServer calls SelectServerFunc.
func (mock *SelectorMock) SelectServer(key string) ServerID {
	if mock.SelectServerFunc == nil {
		panic("SelectorMock.SelectServerFunc: method is nil but Selector.SelectServer was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	mock.lockSelectServer.Lock()
	mock.calls.SelectServer = append(mock.calls.SelectServer, callInfo)
	mock.lockSelectServer.Unlock()
	return mock.SelectServerFunc(key)
}

// SelectServerCalls gets all the calls that were made to SelectServer.
// Check the length with:
//
//	len(mockedSelector.SelectServerCalls())
func (mock *SelectorMock) SelectServerCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	mock.lockSelectServer.RLock()
	calls = mock.calls.SelectServer
	mock.lockSelectServer.RUnlock()
	return calls
}

// SetFailedServer calls SetFailedServerFunc.
func (mock *SelectorMock) SetFailedServer(server ServerID) {
	if mock.SetFailedServerFunc == nil {
		panic("SelectorMock.SetFailedServerFunc: method is nil but Selector.SetFailedServer was just called")
	}
	callInfo := struct {
		Server ServerID
	}{
		Server: server,
	}
	mock.lockSetFailedServer.Lock()
	mock.calls.SetFailedServer = append(mock.calls.SetFailedServer, callInfo)
	mock.lockSetFailedServer.Unlock()
	mock.SetFailedServerFunc(server)
}

// SetFailedServerCalls gets all the calls that were made to SetFailedServer.
// Check the length with:
//
//	len(mockedSelector.SetFailedServerCalls())
func (mock *SelectorMock) SetFailedServerCalls() []struct {
	Server ServerID
} {
	var calls []struct {
		Server ServerID
	}
	mock.lockSetFailedServer.RLock()
	calls = mock.calls.SetFailedServer
	mock.lockSetFailedServer.RUnlock()
	return calls
}

// Ensure, that ServerStatsMock does implement ServerStats.
// If this is not the case, regenerate this file with moq.
var _ ServerStats = &ServerStatsMock{}

// ServerStatsMock is a mock implementation of ServerStats.
//
//	func TestSomethingThatUsesServerStats(t *testing.T) {
//
//		// make and configure a mocked ServerStats
//		mockedServerStats := &ServerStatsMock{
//			GetMemUsageFunc: func(server ServerID) float64 {
//				panic("mock out the GetMemUsage method")
//			},
//			IsServerFailedFunc: func(server ServerID) bool {
//				panic("mock out the IsServerFailed method")
//			},
//			NotifyServerFailedFunc: func(server ServerID)  {
//				panic("mock out the NotifyServerFailed method")
//			},
//		}
//
//		// use mockedServerStats in code that requires ServerStats
//		// and then make assertions.
//
//	}
type ServerStatsMock struct {
	// GetMemUsageFunc mocks the GetMemUsage method.
	GetMemUsageFunc func(server ServerID) float64

	// IsServerFailedFunc mocks the IsServerFailed method.
	IsServerFailedFunc func(server ServerID) bool

	// NotifyServerFailedFunc mocks the NotifyServerFailed method.
	NotifyServerFailedFunc func(server ServerID)

	// calls tracks calls to the methods.
	calls struct {
		// GetMemUsage holds details about calls to the GetMemUsage method.
		GetMemUsage []struct {
			// Server is the server argument value.
			Server ServerID
		}
		// IsServerFailed holds details about calls to the IsServerFailed method.
		IsServerFailed []struct {
			// Server is the server argument value.
			Server ServerID
		}
		// NotifyServerFailed holds details about calls to the NotifyServerFailed method.
		NotifyServerFailed []struct {
			// Server is the server argument value.
			Server ServerID
		}
	}
	lockGetMemUsage        sync.RWMutex
	lockIsServerFailed     sync.RWMutex
	lockNotifyServerFailed sync.RWMutex
}

// GetMemUsage calls GetMemUsageFunc.
func (mock *ServerStatsMock) GetMemUsage(server ServerID) float64 {
	if mock.GetMemUsageFunc == nil {
		panic("ServerStatsMock.GetMemUsageFunc: method is nil but ServerStats.GetMemUsage was just called")
	}
	callInfo := struct {
		Server ServerID
	}{
		Server: server,
	}
	mock.lockGetMemUsage.Lock()
	mock.calls.GetMemUsage = append(mock.calls.GetMemUsage, callInfo)
	mock.lockGetMemUsage.Unlock()
	return mock.GetMemUsageFunc(server)
}

// GetMemUsageCalls gets all the calls that were made to GetMemUsage.
// Check the length with:
//
//	len(mockedServerStats.GetMemUsageCalls())
func (mock *ServerStatsMock) GetMemUsageCalls() []struct {
	Server ServerID
} {
	var calls []struct {
		Server ServerID
	}
	mock.lockGetMemUsage.RLock()
	calls = mock.calls.GetMemUsage
	mock.lockGetMemUsage.RUnlock()
	return calls
}

// IsServerFailed calls IsServerFailedFunc.
func (mock *ServerStatsMock) IsServerFailed(server ServerID) bool {
	if mock.IsServerFailedFunc == nil {
		panic("ServerStatsMock.IsServerFailedFunc: method is nil but ServerStats.IsServerFailed was just called")
	}
	callInfo := struct {
		Server ServerID
	}{
		Server: server,
	}
	mock.lockIsServerFailed.Lock()
	mock.calls.IsServerFailed = append(mock.calls.IsServerFailed, callInfo)
	mock.lockIsServerFailed.Unlock()
	return mock.IsServerFailedFunc(server)
}

// IsServerFailedCalls gets all the calls that were made to IsServerFailed.
// Check the length with:
//
//	len(mockedServerStats.IsServerFailedCalls())
func (mock *ServerStatsMock) IsServerFailedCalls() []struct {
	Server ServerID
} {
	var calls []struct {
		Server ServerID
	}
	mock.lockIsServerFailed.RLock()
	calls = mock.calls.IsServerFailed
	mock.lockIsServerFailed.RUnlock()
	return calls
}

// NotifyServerFailed calls NotifyServerFailedFunc.
func (mock *ServerStatsMock) NotifyServerFailed(server ServerID) {
	if mock.NotifyServerFailedFunc == nil {
		panic("ServerStatsMock.NotifyServerFailedFunc: method is nil but ServerStats.NotifyServerFailed was just called")
	}
	callInfo := struct {
		Server ServerID
	}{
		Server: server,
	}
	mock.lockNotifyServerFailed.Lock()
	mock.calls.NotifyServerFailed = append(mock.calls.NotifyServerFailed, callInfo)
	mock.lockNotifyServerFailed.Unlock()
	mock.NotifyServerFailedFunc(server)
}

// NotifyServerFailedCalls gets all the calls that were made to NotifyServerFailed.
// Check the length with:
//
//	len(mockedServerStats.NotifyServerFailedCalls())
func (mock *ServerStatsMock) NotifyServerFailedCalls() []struct {
	Server ServerID
} {
	var calls []struct {
		Server ServerID
	}
	mock.lockNotifyServerFailed.RLock()
	calls = mock.calls.NotifyServerFailed
	mock.lockNotifyServerFailed.RUnlock()
	return calls
}
