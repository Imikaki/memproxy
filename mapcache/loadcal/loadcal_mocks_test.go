// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package loadcal

import (
	"sync"
)

// Ensure, that BoundCheckerMock does implement BoundChecker.
// If this is not the case, regenerate this file with moq.
var _ BoundChecker = &BoundCheckerMock{}

// BoundCheckerMock is a mock implementation of BoundChecker.
//
//	func TestSomethingThatUsesBoundChecker(t *testing.T) {
//
//		// make and configure a mocked BoundChecker
//		mockedBoundChecker := &BoundCheckerMock{
//			CheckFunc: func(input CheckBoundInput) CheckBoundOutput {
//				panic("mock out the Check method")
//			},
//		}
//
//		// use mockedBoundChecker in code that requires BoundChecker
//		// and then make assertions.
//
//	}
type BoundCheckerMock struct {
	// CheckFunc mocks the Check method.
	CheckFunc func(input CheckBoundInput) CheckBoundOutput

	// calls tracks calls to the methods.
	calls struct {
		// Check holds details about calls to the Check method.
		Check []struct {
			// Input is the input argument value.
			Input CheckBoundInput
		}
	}
	lockCheck sync.RWMutex
}

// Check calls CheckFunc.
func (mock *BoundCheckerMock) Check(input CheckBoundInput) CheckBoundOutput {
	if mock.CheckFunc == nil {
		panic("BoundCheckerMock.CheckFunc: method is nil but BoundChecker.Check was just called")
	}
	callInfo := struct {
		Input CheckBoundInput
	}{
		Input: input,
	}
	mock.lockCheck.Lock()
	mock.calls.Check = append(mock.calls.Check, callInfo)
	mock.lockCheck.Unlock()
	return mock.CheckFunc(input)
}

// CheckCalls gets all the calls that were made to Check.
// Check the length with:
//
//	len(mockedBoundChecker.CheckCalls())
func (mock *BoundCheckerMock) CheckCalls() []struct {
	Input CheckBoundInput
} {
	var calls []struct {
		Input CheckBoundInput
	}
	mock.lockCheck.RLock()
	calls = mock.calls.Check
	mock.lockCheck.RUnlock()
	return calls
}

// Ensure, that SizeLogUpdaterMock does implement SizeLogUpdater.
// If this is not the case, regenerate this file with moq.
var _ SizeLogUpdater = &SizeLogUpdaterMock{}

// SizeLogUpdaterMock is a mock implementation of SizeLogUpdater.
//
//	func TestSomethingThatUsesSizeLogUpdater(t *testing.T) {
//
//		// make and configure a mocked SizeLogUpdater
//		mockedSizeLogUpdater := &SizeLogUpdaterMock{
//			UpdateFunc: func(key string, sizeLog SizeLog, options UpdateOptions)  {
//				panic("mock out the Update method")
//			},
//		}
//
//		// use mockedSizeLogUpdater in code that requires SizeLogUpdater
//		// and then make assertions.
//
//	}
type SizeLogUpdaterMock struct {
	// UpdateFunc mocks the Update method.
	UpdateFunc func(key string, sizeLog SizeLog, options UpdateOptions)

	// calls tracks calls to the methods.
	calls struct {
		// Update holds details about calls to the Update method.
		Update []struct {
			// Key is the key argument value.
			Key string
			// SizeLog is the sizeLog argument value.
			SizeLog SizeLog
			// Options is the options argument value.
			Options UpdateOptions
		}
	}
	lockUpdate sync.RWMutex
}

// Update calls UpdateFunc.
func (mock *SizeLogUpdaterMock) Update(key string, sizeLog SizeLog, options UpdateOptions) {
	if mock.UpdateFunc == nil {
		panic("SizeLogUpdaterMock.UpdateFunc: method is nil but SizeLogUpdater.Update was just called")
	}
	callInfo := struct {
		Key     string
		SizeLog SizeLog
		Options UpdateOptions
	}{
		Key:     key,
		SizeLog: sizeLog,
		Options: options,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	mock.UpdateFunc(key, sizeLog, options)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//
//	len(mockedSizeLogUpdater.UpdateCalls())
func (mock *SizeLogUpdaterMock) UpdateCalls() []struct {
	Key     string
	SizeLog SizeLog
	Options UpdateOptions
} {
	var calls []struct {
		Key     string
		SizeLog SizeLog
		Options UpdateOptions
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}
